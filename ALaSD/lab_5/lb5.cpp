/*алгоритм обходу графу на основі пошуку в глибину. Передбачити, що
граф може бути як орієнтований, так і неорієнтований. В процесі
пошуку має бути сформовано ліс пошуку в глибину. Для реалізації
має використовуватися стек. Програмне забезпечення має бути
побудовано на основі відповідного класу, який повинен дозволяти
визначати граф, виконувати пошук в глибину, виводити побудований
ліс пошуку в глибину, виводити результат обходу тощо.*/

/*Розробити програмне забезпечення, в якому реалізується
алгоритм обходу графу на основі пошуку в ширину. Передбачити, що
граф може бути як орієнтований, так і неорієнтований. В процесі
пошуку має бути сформовано дерево пошуку в ширину. Для реалізації
має використовуватися черга. Програмне забезпечення має бути
побудовано на основі відповідного класу, який повинен дозволяти
визначати граф, виконувати пошук в ширину, виводити побудоване
дерево пошуку в ширину, виводити результат обходу тощо.*/

/*Використовуючи розроблене програмне забезпечення,
розробити окремі модулі, які використовуються для розв’язання задач
у відповідності з індивідуальним завданням з таблиці 5.1, що
складається з трьох задач, наведених нижче, і реалізують інтерфейсну
взаємодію користувача з програмою, та виконати відповідне
тестування. Обґрунтувати вибір алгоритму обходу графа для кожної
задачі, де це не задано явно.*/

/*Задача 1:
А. Перевірити, чи є заданий граф зв’язним чи ні. Зв’язним
вважають граф, у якому між будь-якою парою вершин існує
щонайменше один шлях.*/

/*Задача 2:
А. Селянин привів на берег річки козла, двох вовків, собаку та
приніс капусту. На березі річки знаходиться човен, який вміщує
тільки три об’єкти: селянина і двох тварин, або селянина, тварину і
капусту. При цьому вовка не можна лишати разом з козлом та
собакою, собаку – з козлом, а козла – з капустою. Визначити, яким
чином селянину перевезти всіх тварин і капусту на інший берег, щоб
продовжити свій шлях.*/

/*Задача 3:
А. Гемптон-Кортський лабіринт площею у 60 акрів привертає
увагу багатьох туристів. Ваш товариш перед тим, як потрапити до
одного з таких лабіринтів і продемонструвати свої здібності, вирішив
вивчити план лабіринту та запитав Вас про допомогу, яким чином
знайти шлях у лабіринті. Змоделюйте лабіринт за допомогою вершин,
що відповідають входу в лабіринт, виходу, глухим кутам, всім точкам
лабіринту, в яких є можливість вибору шляху, та з’єднань даних
вершин ребрами, що відповідають шляхам у лабіринті.*/

#include <iostream>
#include <vector>
using namespace std;


int main(int argc, char const *argv[])
{
    vector<vector<int>> vec;
    vector<int> tmp = {1, 2};
    vec.push_back(tmp);

    cout << vec[0][0] << " " << vec[0][1];
    return 0;
}
